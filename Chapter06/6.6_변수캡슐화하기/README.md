## 6.6 변수 캡슐화하기

> 필드 캡슐화

```js
// before
let defaultOwner = { firstName: "마틴", lastName: "파울러" };

// after
let defaultOwnerData = { firstName: "마틴", lastName: "파울러" };

export function defaultOwner() {
  return defaultOwnerData;
}

export function setDefaultOwner(arg) {
  defaultOwnerData = arg;
}
```

### 배경

> 데이터는 함수보다 다루기 까다롭다.

- 참조하는 모든 부분을 한번에 바꿔야 코드가 제대로 작동한다.
- 유효범위가 넓어질수록 다루기 어려워진다.
- 따라서 접근 가능 범위가 넓은 데이터를 옮길 때는, 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 `캡슐화`하는게 좋다!!!
  - = 데이터 유효범위가 넓을수록 캡슐화해야 한다. (`데이터 캡슐화`)
  - 데이터 재구성 대신 함수를 재구성!
  - 데이터 변경, 사용을 감시하는 확실한 통로 역할
    - getter, setter
      - getter가 복제본을 반환하도록 처리하면, 클라이언트는 게터로 얻은 데이터를 변경할 수 있지만, 원본에는 아무 영향을 주지 못하게 됨  
    - 변경 전 검증이나, 변경 후 추가로직을 쉽게 끼워넣을 수 있음
  - 객체지향에서 객체 데이터를 `private`으로 유지하는 이유
  - 불변 데이터는 데이터 변경될 일이 거의 없어서, 가변 데이터보다 캡슐화할 이유가 적다!

### 절차

1. 변수로 접근, 갱신을 담당하는 캡슐화 함수들 만들기
2. 정적 검사
3. 변수 참조 부분을 모두 적절한 캡슐화 함수호출로 바꾸기 (with 테스트)
4. 변수 접근범위 제한
5. 테스트
6. 변수값이 레코드라면, 레코드 캡슐화도 고려해보기
