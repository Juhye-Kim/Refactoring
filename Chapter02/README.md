## Chapter02. 리팩터링 원칙

### 리팩터링 정의

> 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이런 단계들을 순차적으로 연결해 큰 변화를 만들어내는 일

- [명사] 소프트웨어 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부구조를 변경하는 기법
  - ex. 함수 추출하기, 조건부 로직 다형성으로 바꾸기...
- [동사] 소프트웨어 겉보기 동작은 그대로 유지한 채, 여러 리팩터링 기법을 적용해 소프트웨어를 재구성하는 것

<br>

### 두 개의 모자

> 소프트웨어를 개발하는 동안 나는 두 모자를 자주 바꿔쓴다.

1. 기능 추가 모자
   - 기존 코드는 절대 건드리지 않고, 새 기능을 추가만 한다.
   - 진척도는 테스트를 추가해 통과하는지 확인하며 측정
2. 리팩터링 모자
   - 기능추가는 절대 하지 않고, 오로지 코드 재구성에만 전념한다.
   - 테스트도 새로 만들지 않는다.
     - 앞에서 놓친 테스트케이스를 발견하지 않는 한,,
     - 부득이 인터페이스 변경해야 할 때만 수정

> 새 기능을 추가하다 보면 코드구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔쓰고 리팩터링한다.

<br>

### 리팩터링하는 이유

1. 소프트웨어 설계가 좋아진다.
   - 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
   - 설계가 나쁘면 코드가 길어지고, 실수없이 수정하기 어려워진다.
2. 소프트웨어를 이해하기 쉬워진다.
   - 리팩터링은 코드가 더 잘 읽히게 도와준다.
     - 나중에 그 코드를 다룰 개발자를 위한 배려
       - 그 사람이 바로 나 자신일 때가 많다..
   - 코드의 목적이, 내 의도가 더 명확하게 전달되도록 개선
3. 버그를 쉽게 찾을 수 있다.
   - 코드가 하는 일을 파악하게 된다.
   - '이럴 것이다'라고 가정하던 점들이 분명히 드러난다.
     - 버그를 지나치려야 지나칠 수 없을 정도로 명확해진다.
4. 코드 개발 속도를 높일 수 있다.
   - 안좋은 코드는 새로운 기능을 추가할수록 시간이 오래걸린다.
   - '설계 지구력 가설'
     - 내부설계에 심혈을 기울이면, 소프트웨어 지구력이 높아져 빠르게 개발가능한 상태를 더 오래 지속할 수 있다.

### 언제 리팩터링해야 할까?

**3의 법칙 (by 돈 로버츠)**

1. 처음에는 그냥 한다.
2. 비슷한 일을 두번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세번째로 하게 되면, 리팩터링한다.

<br>

**준비를 위한 리팩터링**

> 기능을 쉽게 추가할 수 있도록 만들기

- 기능을 새로 추가하기 직전에, 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워진다.
- ex. 함수 매개변수화하기
  - 나중에는 그 함수에 필요한 매개변수를 지정해서 호출만 하면 됨
- 오류를 일으키는 코드가 여러 곳에 퍼져있다면, 우선 한 곳으로 합치는 편이 작업하기 훨씬 편하다.

<br>

**이해를 위한 리팩터링**

> 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아보기

- ex. 조건부 로직 구조가 이상하지 않은지 살펴보기
- ex. 함수명을 잘못 정해서 역할을 파악하는 데 시간이 오래 걸리지 않는지 살펴보기

<br>

**쓰레기 줍기 리팩터링**

> 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

- 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.
- 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.

<br>

**계획된 리팩터링, 수시로 하는 리팩터링**

> 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.

- 보기 싫은 코드를 발견하면 리팩터링하자.
- 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다.

<br>

**오래 걸리는 리팩터링**

> 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적일 때가 많다.

- 조금씩, 원하는 방향으로 개선하는 식이다.

<br>

**코드리뷰에 리팩터링 활용하기**

> 리팩터링은 다른이의 코드를 리뷰하는 데도 도움된다.

- 떠올린 아이디어를 실제로 적용했을 때 모습을 좀 더 명확하게 볼 수 있다.
- 코드리뷰 결과를 즉시 구현해 볼 수 있다.

**리팩터링하지 말아야 할 때**

1. 외부 API 다루듯 호출해서 쓰는 코드일 때
   - 내부 동작을 이해해야할 시점에 리팩터링해야 효과를 제대로 볼 수 있음
2. 처음부터 새로 작성하는 게 쉬울 때
   - 경험을 많이 쌓아야 쉬운지 안쉬운지 판단 가능

<br>

### 리팩터링할 때 고려할 문제

**새 기능 개발 속도 저하**

- 리팩터링의 궁극적 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
    - 직접 건드릴 일이 거의 없거나, 불편함이 그리 심하지 않으면 리팩토링하지 않기도 한다.
- 리팩터링의 본질은 코드베이스를 예쁘게 하는게 아니라, 경제적인 이유에서이다!
    - 기능 추가, 버그 수정 시간을 줄이기 위해서

**코드 소유권**

- 함수명을 바꾸려할 때, 해당 함수를 호출하는 코드의 소유자가 내가 아닌 경우, 리팩터링에 방해가 된다.
    - ex. API로 제공되는 경우
- 코드 소유권을 팀에 두고, 팀원 누구나 코드를 수정할 수 있게 해야한다.

**브랜치**

- 독립 브랜치로 작업 후, 마스터로 통합
    - 통합을 쉽게 하기위해 수시로 merge
    - 통합 주기를 짧게 관리하기 (지속적 통합(CI), 토렁크 기반 개발(TBD))

**XP(extreme programing)**

> 지속적 통합, 자가테스트 코드, 리팩터링 등의 기법들을 묶은 하나의 프로세스

- 지속적 통합(CI)
  - 리팩토링 결과를 빠르게 동료와 공유
- 자가 테스트 코드
  - 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행

<br>

### 유연성 메커니즘
> 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.

- 복잡성을 높일 수 있는 유연성 메커니즘은 반드시 검증 후 추가한다.
- 간결한 설계, 점진적 설계, YAGNI

**YAGNI (애그니)**
> you aren't going to need it (필요없을거다)

- XP(extreme programing) 원칙 중 하나
- **당장 필요한 기능만으로 최대한 간결하게 만들어라!**
    - '필요할 것 같아서' 만든 기능 중 상당수가 쓰이지 않거나, 미래 요구사항을 제대로 반영하지 못해 오히려 수정하기 힘들어 질 수 있음
    - 나중에 문제를 더 깊이 이해하게 되었을 때 처리하는쪽이 나을 수 있음
- 리팩토링은 YAGNI의 토대가 되고, YAGNI는 리팩터링을 더욱 쉽게 만들어줌
